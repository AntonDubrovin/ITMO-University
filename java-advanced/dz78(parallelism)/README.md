Домашнее задание 7. Итеративный параллелизм
----
1. Реализуйте класс IterativeParallelism, который будет обрабатывать списки в несколько потоков.
2. В простом варианте должны быть реализованы следующие методы:
   * minimum(threads, list, comparator) — первый минимум;
   * maximum(threads, list, comparator) — первый максимум;
   * all(threads, list, predicate) — проверка, что все элементы списка удовлетворяют предикату;
   * any(threads, list, predicate) — проверка, что существует элемент списка, удовлетворяющий предикату.
3. В сложном варианте должны быть дополнительно реализованы следующие методы:
   * filter(threads, list, predicate) — вернуть список, содержащий элементы удовлетворяющие предикату;
   * map(threads, list, function) — вернуть список, содержащий результаты применения функции;
   * join(threads, list) — конкатенация строковых представлений элементов списка.
4. Во все функции передается параметр threads — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков не велико.
5. Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6. При выполнении задания нельзя использовать Concurrency Utilities.
7. Рекомендуется подумать, какое отношение к заданию имеют моноиды.

Домашнее задание 8. Параллельный запуск
----
1. Напишите класс ParallelMapperImpl, реализующий интерфейс ParallelMapper.
```
public interface ParallelMapper extends AutoCloseable {
    <T, R> List<R> map(
        Function<? super T, ? extends R> f,
        List<? extends T> args
    ) throws InterruptedException;

    @Override
    void close() throws InterruptedException;
}
```
   * Метод run должен параллельно вычислять функцию f на каждом из указанных аргументов (args).
   * Метод close должен останавливать все рабочие потоки.
   * Конструктор ParallelMapperImpl(int threads) создает threads рабочих потоков, которые могут быть использованы для распараллеливания.
   * К одному ParallelMapperImpl могут одновременно обращаться несколько клиентов.
   * Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
   * В реализации не должно быть активных ожиданий.
2. Доработайте класс IterativeParallelism так, чтобы он мог использовать ParallelMapper.
   * Добавьте конструктор IterativeParallelism(ParallelMapper)
   * Методы класса должны делить работу на threads фрагментов и исполнять их при помощи ParallelMapper.
   * При наличии ParallelMapper сам IterativeParallelism новые потоки создавать не должен.
   * Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один ParallelMapper.
